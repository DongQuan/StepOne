####1. JVM如何加载一个类的过程，双亲委派模型中有哪些方法？

答:

#####jvm将类加载过程分成加载，连接，初始化三个阶段，其中连接阶段又细分为验证，准备，解析三个阶段。

- 装载阶段主要是将java字节码以二进制的方式读入到jvm内存中，然后将二进制数据流按照字节码规范解析成jvm内部的运行时数据结构。
- 连接阶段主要是做一些加载完成之后的验证工作，和初始化之前的准备一些工作，它细分为三个阶段。
    + 验证:验证是连接阶段的第一步，它主要是用于保证加载的字节码符合java语言的规范，并且不会给虚拟机带来危害。
            比如验证这个类是不是符合字节码的格式、变量与方法是不是有重复、数据类型是不是有效、继承与实现是否合乎标准等等。
    + 准备:准备阶段主要是为类的静态变量分配内存，并设置jvm默认的初始值。对于非静态的变量，则不会为它们分配内存。
    + 解析:解析过程就是查找类的常量池中的类，字段，方法，接口的符号引用，将他们替换成直接引用的过程。
- 初始化阶段是根据用户程序中的初始化语句为类的静态变量赋予正确的初始值。
    +  初始化执行时机:
       jvm规范明确规定了初始化执行条件，只要满足以下四个条件之一，就会执行初始化工作
       1. 通过new关键字实例化对象、读取或设置类的静态变量、调用类的静态方法(对应new,getstatic,putstatic,invokespecial这四条字节码指令）。
       2. 通过反射方式执行以上行为时。
       3. 初始化子类的时候，会触发父类的初始化。
       4. 作为程序入口直接运行时的主类。
    + 初始化过程:
        初始化过程包括两步：
       1. 如果类存在直接父类，并且父类没有被初始化则对直接父类进行初始化。
       2. 如果类当前存在<clinit>()方法，则执行<clinit>()方法。
    + <clinit>()方法存在的条件:
        并不是每个类都有<clinit>()方法,如下情况下不会有<clinit>()方法：
       1. 类没有静态变量也没有静态语句块
       2. 类中虽然定义了静态变量，但是没有给出明确的初始化语句。
       3. 如果类中仅包含了final static 的静态变量的初始化语句，而且初始化语句采用编译时常量表达时，
       也不会有<clinit>()方法。
    + 并发性:
        在同一个类加载器域下，每个类只会被初始化一次，当多个线程都需要初始化同一个类，
        这时只允许一个线程执行初始化工作，其他线程则等待。当初始化执行完后，该线程会通知其他等待的线程。
            
#####双亲委派模型:

站在虚拟机的角度上，只存在两种不同的类加载器：一种是启动类加载器(Bootstrap ClassLoader)，这个类加载器使用C++语言实现，是虚拟机自身的一部分；另外一种就是其它所有的类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全部继承自java.lang.ClassLoader。
从Java开发人员的角度看，类加载器还可以划分得更细一些，如下：

1. 启动类加载器(Bootstrap ClassLoader)：这个类加载器负责将放置在<JAVA_HOME>\lib目录中的，
或者被-Xbootclasspath参数所指定路径中的，并且是虚拟机能识别的(仅按照文件名识别，如rt.jar，
名字不符合的类库即使放置在lib目录中也不会被加载)类库加载到虚拟机内存中。启动类加载器无法被Java程序直接使用。
2. 扩展类加载器(Extension ClassLoader)：这个类加载器由sun.misc.Launcher$ExtClassLoader实现，
它负责加载<JAVA_HOME>\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，
开发者可以直接使用扩展类加载器。
3. 应用程序类加载器(Application ClassLoader)：这个类加载器由sum.misc.Launcher.$AppClassLoader来实现。
由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也被称为系统类加载器。
它负责加载用户类路径上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，
一般情况下这个就是程序中默认的类加载器。

上图中展示的类加载器之间的层次关系，就称为类加载器的双亲委派模型(Parents Delegation Model)。
双亲委派模型要求除了顶层的启动类加载器之外，其余的类加载器都应当有自己的父类加载器。
这里的类加载器之间的父子关系一般不会以继承的关系来实现，而是使用组合关系来复用父加载器的代码。

双亲委派模型的式作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，
而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，
只有当父加载器反馈自己无法完全这个加载请求时，子加载器才会尝试自己去加载。
    
    
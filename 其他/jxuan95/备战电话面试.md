###备战电话面试
___

#####目录
* [1.数据结构](#1)
	+ [1.1测试](#1.1)
	+ [1.2测试](#1.2)
* [2.算法](#2)
* [3.网络基础](#3)
* [4.Java基础](#4)
	+ [4.1抽象类与接口的区别](#4.1)
	+ [4.2什么时候用抽象类什么时候用接口](#4.2)
	+ [4.3面向对象的特点](#4.3)
	+ [4.4什么是多态，多态的表现形式](#4.4)
	+ [4.5归并排序具体过程，适用场合](#4.5)
	+ [4.6集合类的体系结构](#4.6)
	+ [4.7HashMap的具体实现](#4.7)
	+ [4.8进程的通信方式](#4.8)
	+ [4.9GC垃圾收集有哪些算法](#4.9)

___

####<span id="1">1.数据结构</span>

___

####<span id="2">2.算法</span>

___

####<span id="3">3.网络基础</span>

___

####<span id="4">4.Java基础</span>

4.1 <span id="4.1">抽象类与接口的区别</span>

- 接口中所有方法都是抽象的，而抽象类则可有抽象和非抽象的方法。
- 接口中声明的变量默认都是final的，抽象类可以包含非final的变量。
- 类可以实现很多接口，但只能继承一个抽象类。
- 实现接口，必须实现接口的所有方法。继承抽象类可仅实现部分抽象方法。
- Java接口中的成员函数默认是public的，抽象类的成员函数可以是private，protected或者是public。
- 接口是绝对抽象的，不可以被实例化，抽象类也不可以被实例化，但是，如果它包含main方法的话是可以被调用的。
- 抽象类可以在不提供接口方法实现的情况下实现接口。

4.2 <span id="4.2">什么时候用抽象类什么时候用接口</span>

答：在设计类的时候，首先考虑用接口抽象出类的特性，如果某些方法可以复用的时候，可以使用抽象类来复用代码。接口用于抽象事物的特性，抽象类用于代码复用。

4.3 <span id="4.3">面向对象的特点</span>

答：面向对象编程有很多重要的特性，比如：封装，继承，多态和抽象。
+ __封装__：封装给对象提供了隐藏内部特性和行为的能力。对象提供一些能被其他对象访问的方法来改变它内部的数据。在Java当中，有3种修饰符：public，private和protected。每一种修饰符给其他的位于同一个包或者不同包下面对象赋予了不同的访问权限。
+ __继承__：继承给对象提供了从基类获取字段和方法的能力。继承提供了代码的重用行，也可以在不修改类的情况下给现存的类添加新特性。
+ __抽象__：抽象是把想法从具体的实例中分离出来的步骤，因此，要根据他们的功能而不是实现细节来创建类。Java支持创建只暴漏接口而不包含方法实现的抽象的类。这种抽象技术的主要目的是把类的行为和实现细节分离开。
+ __多态__：多态是编程语言给不同的底层数据类型做相同的接口展示的一种能力。一个多态类型上的操作可以应用到其他类型的值上面。

4.4 <span id="4.4">什么是多态，多态的表现形式</span>

答：
* 多态是编程语言给不同的底层数据类型做相同的接口展示的一种能力。一个多态类型上的操作可以应用到其他类型的值上面。
* 表现形式：一种是父类与子类之间表现——重写，还有一种是重载,在同一个类中，同样的方法，有不同的实现方式。

4.5 <span id="4.5">归并排序具体过程，适用场合</span>

答：

4.6 <span id="4.6">集合类的体系结构</span>

答：Java集合类里面最基本的接口有：
  
   - Collection：代表一组对象，每一个对象都是它的子元素。
       + List：有顺序的collection，并且可以包含重复元素。
           - LinkedList实现了List接口，允许null元素。此外LinkedList提供额外的get，remove，insert方法在LinkedList的首部或尾部。这些操作使LinkedList可被用作堆栈（stack），队列（queue）或双向队列（deque）。 
           - ArrayList实现了可变大小的数组。它允许所有元素，包括null。ArrayList没有同步。 
           - Vector非常类似ArrayList，但是Vector是同步的。
           - Stack类:Stack继承自Vector，实现一个后进先出的堆栈。
       + Set：不包含重复元素的Collection。Set接口也是Collection的一种扩展，而与List不同的时，在Set中的对象元素不能重复。它的常用具体实现有HashSet和TreeSet类。
           - HashSet能快速定位一个元素，但是你放到HashSet中的对象需要实现hashCode()方法，它使用了哈希码的算法。
           - TreeSet则将放入其中的元素按序存放，这就要求你放入其中的对象是可排序的。
   - Map：Map没有实现Collection接口，Map提供key到value的映射。一个Map中不能包含相同的key，每个key只能映射一个value。
       +  Hashtable继承了Dictionary类，实现了Map接口，实现一个key-value映射的哈希表。任何非空（non-null）的对象都可作为key或者value。
       +  HashMap和Hashtable类似，不同之处在于HashMap是非同步的，并且允许null，即null value和null key。
       +  TreeMap 继承于AbstractMap，TreeMap 是一个有序的key-value集合，它是通过红黑树实现的。
       +  TreeMap基于红黑树（Red-Black tree）实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。

4.7 <span id="4.7">HashMap的具体实现</span>

答：Java中的HashMap是以键值对(key-value)的形式存储元素的。HashMap需要一个hash函数，它使用hashCode()和equals()方法来向集合/从集合添加和检索元素。当调用put()方法的时候，HashMap会计算key的hash值，然后把键值对存储在集合中合适的索引上。如果key已经存在了，value会被更新成新值。HashMap的一些重要的特性是它的容量(capacity)，负载因子(load factor)和扩容极限(threshold resizing)。

4.7 <span id="4.8">进程的通信方式</span>

答：

4.7 <span id="4.8">GC垃圾收集有哪些算法</span>

- __标记-清除__:这是垃圾收集算法中最基础的，它的思想就是标记哪些要被回收的对象，然后统一回收。这种方法很简单，但是会有两个主要问题：
      + 效率不高，标记和清除的效率都很低；
      + 会产生大量不连续的内存碎片，导致以后程序在分配较大的对象时，由于没有充足的连续内存而提前触发一次GC动作。
 
- __复制算法__:为了解决效率问题，复制算法将可用内存按容量划分为相等的两部分，然后每次只使用其中的一块，当一块内存用完时，就将还存活的对象复制到第二块内存上，然后一次性清楚完第一块内存，再将第二块上的对象复制到第一块。但是这种方式，内存的代价太高，每次基本上都要浪费一半的内存。于是将该算法进行了改进，内存区域不再是按照1：1去划分，而是将内存划分为8:1:1三部分，较大那份内存叫Eden区，其余是两块较小的内存区叫Survior区。每次都会优先使用Eden区，若Eden区满，就将对象复制到第二块内存区上，然后清除Eden区，如果此时存活的对象太多，以至于Survivor不够时，会将这些对象通过分配担保机制复制到老年代中。(java堆又分为新生代和老年代)
<br/>
- __标记-整理__:该算法主要是为了解决标记-清除，产生大量内存碎片的问题；当对象存活率较高时，也解决了复制算法的效率问题。它的不同之处就是在清除对象的时候现将可回收对象移动到一端，然后清除掉端边界以外的对象，这样就不会产生内存碎片了。
<br/>
- __分代收集__: 现在的虚拟机垃圾收集大多采用这种方式，它根据对象的生存周期，将堆分为新生代和老年代。在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这时就采用复制算法。老年代里的对象存活率较高，没有额外的空间进行分配担保，所以可以使用标记-整理 或者 标记-清除。


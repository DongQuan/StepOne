###备战电话面试
___

#####目录
* [1.数据结构](#1)
	+ [1.1测试](#1.1)
	+ [1.2测试](#1.2)
* [2.算法](#2)
* [3.网络基础](#3)
* [4.Java基础](#4)
	+ [4.1 抽象类与接口的区别](#4.1)
	+ [4.2 什么时候用抽象类什么时候用接口](#4.2)
	+ [4.3 面向对象的特点](#4.3)
	+ [4.4 什么是多态，多态的表现形式](#4.4)
	+ [4.5 归并排序具体过程，适用场合](#4.5)
	+ [4.6 集合类的体系结构](#4.6)
	+ [4.7 HashMap的具体实现](#4.7)
	+ [4.8 进程的通信方式](#4.8)
	+ [4.9 GC垃圾收集有哪些算法](#4.9)
	+ [4.10 什么情况下会触发垃圾收集](#4.10)
	+ [4.11 新生代与老年代各存储对象是什么](#4.11)
	+ [4.12 新生代的垃圾收集过程](#4.12)
	+ [4.13 CMS收集器](#4.13)
* [5.数据库](#5)
    + [5.1 数据库事务是什么](#5.1)
    + [5.2 数据库事务的特性](#5.2)
    + [5.3 如何并发访问数据库](#5.3)
    + [5.4 数据库有哪些锁](#5.4)

___

####<span id="1">1.数据结构</span>

___

####<span id="2">2.算法</span>

___

####<span id="3">3.网络基础</span>

___

####<span id="4">4.Java基础</span>

#####4.1 <span id="4.1">抽象类与接口的区别</span>

- 接口中所有方法都是抽象的，而抽象类则可有抽象和非抽象的方法。
- 接口中声明的变量默认都是final的，抽象类可以包含非final的变量。
- 类可以实现很多接口，但只能继承一个抽象类。
- 实现接口，必须实现接口的所有方法。继承抽象类可仅实现部分抽象方法。
- Java接口中的成员函数默认是public的，抽象类的成员函数可以是private，protected或者是public。
- 接口是绝对抽象的，不可以被实例化，抽象类也不可以被实例化，但是，如果它包含main方法的话是可以被调用的。
- 抽象类可以在不提供接口方法实现的情况下实现接口。

#####4.2 <span id="4.2">什么时候用抽象类什么时候用接口</span>

答：在设计类的时候，首先考虑用接口抽象出类的特性，如果某些方法可以复用的时候，可以使用抽象类来复用代码。接口用于抽象事物的特性，抽象类用于代码复用。

#####4.3 <span id="4.3">面向对象的特点</span>

答：面向对象编程有很多重要的特性，比如：封装，继承，多态和抽象。
+ __封装__：封装给对象提供了隐藏内部特性和行为的能力。对象提供一些能被其他对象访问的方法来改变它内部的数据。在Java当中，有3种修饰符：public，private和protected。每一种修饰符给其他的位于同一个包或者不同包下面对象赋予了不同的访问权限。
+ __继承__：继承给对象提供了从基类获取字段和方法的能力。继承提供了代码的重用行，也可以在不修改类的情况下给现存的类添加新特性。
+ __抽象__：抽象是把想法从具体的实例中分离出来的步骤，因此，要根据他们的功能而不是实现细节来创建类。Java支持创建只暴漏接口而不包含方法实现的抽象的类。这种抽象技术的主要目的是把类的行为和实现细节分离开。
+ __多态__：多态是编程语言给不同的底层数据类型做相同的接口展示的一种能力。一个多态类型上的操作可以应用到其他类型的值上面。

#####4.4 <span id="4.4">什么是多态，多态的表现形式</span>

答：
* 多态是编程语言给不同的底层数据类型做相同的接口展示的一种能力。一个多态类型上的操作可以应用到其他类型的值上面。
* 表现形式：一种是父类与子类之间表现——重写，还有一种是重载,在同一个类中，同样的方法，有不同的实现方式。

#####4.5 <span id="4.5">归并排序具体过程，适用场合</span>

答：

#####4.6 <span id="4.6">集合类的体系结构</span>

答：Java集合类里面最基本的接口有：
  
   - Collection：代表一组对象，每一个对象都是它的子元素。
       + List：有顺序的collection，并且可以包含重复元素。
           - LinkedList实现了List接口，允许null元素。此外LinkedList提供额外的get，remove，insert方法在LinkedList的首部或尾部。这些操作使LinkedList可被用作堆栈（stack），队列（queue）或双向队列（deque）。 
           - ArrayList实现了可变大小的数组。它允许所有元素，包括null。ArrayList没有同步。 
           - Vector非常类似ArrayList，但是Vector是同步的。
           - Stack类:Stack继承自Vector，实现一个后进先出的堆栈。
       + Set：不包含重复元素的Collection。Set接口也是Collection的一种扩展，而与List不同的时，在Set中的对象元素不能重复。它的常用具体实现有HashSet和TreeSet类。
           - HashSet能快速定位一个元素，但是你放到HashSet中的对象需要实现hashCode()方法，它使用了哈希码的算法。
           - TreeSet则将放入其中的元素按序存放，这就要求你放入其中的对象是可排序的。
   - Map：Map没有实现Collection接口，Map提供key到value的映射。一个Map中不能包含相同的key，每个key只能映射一个value。
       +  Hashtable继承了Dictionary类，实现了Map接口，实现一个key-value映射的哈希表。任何非空（non-null）的对象都可作为key或者value。
       +  HashMap和Hashtable类似，不同之处在于HashMap是非同步的，并且允许null，即null value和null key。
       +  TreeMap 继承于AbstractMap，TreeMap 是一个有序的key-value集合，它是通过红黑树实现的。
       +  TreeMap基于红黑树（Red-Black tree）实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。

#####4.7 <span id="4.7">HashMap的具体实现</span>

答：Java中的HashMap是以键值对(key-value)的形式存储元素的。HashMap需要一个hash函数，它使用hashCode()和equals()方法来向集合/从集合添加和检索元素。当调用put()方法的时候，HashMap会计算key的hash值，然后把键值对存储在集合中合适的索引上。如果key已经存在了，value会被更新成新值。HashMap的一些重要的特性是它的容量(capacity)，负载因子(load factor)和扩容极限(threshold resizing)。

#####4.8 <span id="4.8">进程的通信方式</span>

答：

#####4.9 <span id="4.9">GC垃圾收集有哪些算法</span>

- __标记-清除__:这是垃圾收集算法中最基础的，它的思想就是标记哪些要被回收的对象，然后统一回收。这种方法很简单，但是会有两个主要问题：
      + 效率不高，标记和清除的效率都很低；
      + 会产生大量不连续的内存碎片，导致以后程序在分配较大的对象时，由于没有充足的连续内存而提前触发一次GC动作。
 
- __复制算法__:为了解决效率问题，复制算法将可用内存按容量划分为相等的两部分，然后每次只使用其中的一块，当一块内存用完时，就将还存活的对象复制到第二块内存上，然后一次性清楚完第一块内存，再将第二块上的对象复制到第一块。但是这种方式，内存的代价太高，每次基本上都要浪费一半的内存。于是将该算法进行了改进，内存区域不再是按照1：1去划分，而是将内存划分为8:1:1三部分，较大那份内存叫Eden区，其余是两块较小的内存区叫Survior区。每次都会优先使用Eden区，若Eden区满，就将对象复制到第二块内存区上，然后清除Eden区，如果此时存活的对象太多，以至于Survivor不够时，会将这些对象通过分配担保机制复制到老年代中。(java堆又分为新生代和老年代)
<br/>
- __标记-整理__:该算法主要是为了解决标记-清除，产生大量内存碎片的问题；当对象存活率较高时，也解决了复制算法的效率问题。它的不同之处就是在清除对象的时候现将可回收对象移动到一端，然后清除掉端边界以外的对象，这样就不会产生内存碎片了。
<br/>
- __分代收集__: 现在的虚拟机垃圾收集大多采用这种方式，它根据对象的生存周期，将堆分为新生代和老年代。在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这时就采用复制算法。老年代里的对象存活率较高，没有额外的空间进行分配担保，所以可以使用标记-整理 或者 标记-清除。

#####4.10 <span id="4.10">什么情况下会触发垃圾收集</span>

答：在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。

#####4.11 <span id="4.11">新生代与老年代各存储对象是什么</span>

答：对象一般出生在Eden区，年轻代GC过程中，对象在2个survivor区之间移动，如果对象存活到适当的年龄，会被移动到老年代。当对象在老年代死亡时，就需要更高级别的GC，更重量级的GC算法(复制算法不适用于老年代，因为没有多余的空间用于复制)。老年代存储大对象和长期存活的对象。

#####4.12 <span id="4.12">新生代的垃圾收集过程</span>

答：新生代的GC 使用复制算法。在GC前To 幸存区(survivor)保持清空,对象保存在 Eden 和 From 幸存区(survivor)中，GC运行时,Eden中的幸存对象被复制到 To 幸存区(survivor)。针对 From 幸存区(survivor)中的幸存对象，会考虑对象年龄,如果年龄没达到阀值(tenuring threshold)，对象会被复制到To 幸存区(survivor)。如果达到阀值对象被复制到老年代。复制阶段完成后，Eden 和From 幸存区中只保存死对象，可以视为清空。如果在复制过程中To 幸存区被填满了，剩余的对象会被复制到老年代中。最后 From 幸存区和 To幸存区会调换下名字，在下次GC时，To survivor区会成为From survivor区。

#####4.13 <span id="4.13">CMS收集器</span>

答：HotSpot JVM的并发标记清理收集器(CMS收集器)的主要目标就是：低应用停顿时间。该目标对于大多数交互式应用很重要，比如web应用。

- CMS收集器被设计成在大多数时间能与应用程序线程并行执行，仅仅会有一点(短暂的)停顿时间。GC与应用程序并行的缺点就是，可能会出现各种同步和数据不一致的问题。为了实现安全且正确的并发执行，CMS收集器的GC周期被分为了好几个连续的阶段。
- CMS收集器的过程：CMS收集器的GC周期由6个阶段组成。其中4个阶段(名字以Concurrent开始的)与实际的应用程序是并发执行的，而其他2个阶段需要暂停应用程序线程。
    + 初始标记：为了收集应用程序的对象引用需要暂停应用程序线程，该阶段完成后，应用程序线程再次启动。
    + 并发标记：从第一阶段收集到的对象引用开始，遍历所有其他的对象引用。
    + 并发预清理：改变当运行第二阶段时，由应用程序线程产生的对象引用，以更新第二阶段的结果。
    + 重标记：由于第三阶段是并发的，对象引用可能会发生进一步改变。因此，应用程序线程会再一次被暂停以更新这些变化，并且在进行实际的清理之前确保一个正确的对象引用视图。这一阶段十分重要，因为必须避免收集到仍被引用的对象。
    + 并发清理：所有不再被应用的对象将从堆里清除掉。
    + 并发重置：收集器做一些收尾的工作，以便下一次GC周期能有一个干净的状态。

___

####<span id="5">5.数据库</span>

#####5.1<span id="5.1">数据库事务是什么</span>

答：数据库事务（简称：事务）是数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。

#####5.2<span id="5.2">数据库事务的特性</span>

- 原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。
- 一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。
- 隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。
- 持久性（Durability）：已被提交的事务对数据库的修改应该永久保存在数据库中。

#####5.3<span id="5.3">如何并发访问数据库</span>

答：

#####5.4<span id="5.4">数据库有哪些锁</span>

答：共享锁， 独占所， 修改所，结构锁，意向锁，批量修改锁
- __共享锁__：SQL Server中，共享锁用于所有的只读数据操作。共享锁是非独占的，允许多个并发事务读取其锁定的资源。默认情况下，数据被读取后，SQL Server立即释放共享锁。
<br/>
- __修改锁__：修改锁在修改操作的初始化阶段用来锁定可能要被修改的资源，这样可以避免使用共享锁造成的死锁现象。因为使用共享锁时，修改数据的操作分为两步，首先获得一 个共享锁，读取数据，然后将共享锁升级为独占锁，然后再执行修改操作。这样如果同时有两个或多个事务同时对一个事务申请了共享锁，在修改数据的时候，这些 事务都要将共享锁升级为独占锁。这时，这些事务都不会释放共享锁而是一直等待对方释放，这样就造成了死锁。如果一个数据在修改前直接申请修改锁，在数据修 改的时候再升级为独占锁，就可以避免死锁。修改锁与共享锁是兼容的，也就是说一个资源用共享锁锁定后，允许再用修改锁锁定。 
- __独占锁__：独占锁是为修改数据而保留的。它所锁定的资源，其他事务不能读取也不能修改。独占锁不能和其他锁兼容。
 <br/>
- __结构锁__：结构锁分为结构修改锁（Sch-M）和结构稳定锁（Sch-S）。执行表定义语言操作时，SQL Server采用Sch-M锁，编译查询时，SQL Server采用Sch-S锁。
<br/>
- __意向锁__：意向锁说明SQL Server有在资源的低层获得共享锁或独占锁的意向。例如，表级的共享意向锁说明事务意图将独占锁释放到表中的页或者行。意向锁又可以分为共享意向锁、 独占意向锁和共享式独占意向锁。共享意向锁说明事务意图在共享意向锁所锁定的低层资源上放置共享锁来读取数据。独占意向锁说明事务意图在共享意向锁所锁定 的低层资源上放置独占锁来修改数据。共享式独占锁说明事务允许其他事务使用共享锁来读取顶层资源，并意图在该资源低层上放置独占锁。
<br/>
- __批量修改锁__：批量复制数据时使用批量修改锁。

